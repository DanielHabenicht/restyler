-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | IO without any non-error, synchronous exceptions
--   
--   When you've caught all the exceptions that can be handled safely, this
--   is what you're left with.
--   
--   It is intended that you use qualified imports with this library.
--   
--   <pre>
--   import UnexceptionalIO (UIO)
--   import qualified UnexceptionalIO as UIO
--   </pre>
@package unexceptionalio
@version 0.3.0


-- | When you've caught all the exceptions that can be handled safely, this
--   is what you're left with.
--   
--   <pre>
--   runEitherIO . fromIO â‰¡ id
--   </pre>
module UnexceptionalIO

-- | IO without any non-error, synchronous exceptions
data UIO a

-- | Polymorphic base without any non-error, synchronous exceptions
class Unexceptional m
liftUIO :: Unexceptional m => UIO a -> m a

-- | Catch any non-error, synchronous exceptions in an <a>IO</a> action
fromIO :: IO a -> UIO (Either SomeException a)

-- | Re-embed <a>UIO</a> into <a>IO</a>
runUIO :: UIO a -> IO a

-- | Re-embed <a>UIO</a> and possible exception back into <a>IO</a>
runEitherIO :: (Exception e) => UIO (Either e a) -> IO a

-- | You promise that <tt>e</tt> covers all non-error, synchronous
--   exceptions thrown by this <a>IO</a> action
--   
--   This function is partial if you lie
fromIO' :: (Exception e) => IO a -> UIO (Either e a)

-- | You promise there are no exceptions thrown by this <a>IO</a> action
unsafeFromIO :: IO a -> UIO a

-- | Catch all exceptions, except for asynchronous exceptions found in
--   <tt>base</tt>
syncIO :: IO a -> IO (Either SomeException a)
instance UnexceptionalIO.Unexceptional UnexceptionalIO.UIO
instance UnexceptionalIO.Unexceptional GHC.Types.IO
instance GHC.Base.Functor UnexceptionalIO.UIO
instance GHC.Base.Applicative UnexceptionalIO.UIO
instance GHC.Base.Monad UnexceptionalIO.UIO
instance Control.Monad.Fix.MonadFix UnexceptionalIO.UIO
