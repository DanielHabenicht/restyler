-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package restyler
@version 0.1.0.0

module Restyler.Prelude

-- | <tt><a>when</a></tt> with a monadic condition
--   
--   <pre>
--   x &lt;- someMonadicConditional
--   when x $ do
--       someMonadicAction
--   
--   whenM someMonadicConditional someMonadicAction
--   </pre>
whenM :: Monad m => m Bool -> m () -> m ()

-- | Same for <tt><a>unless</a></tt>
unlessM :: Monad m => m Bool -> m () -> m ()

-- | <tt><a>Show</a></tt> as <tt><a>Text</a></tt>
tshow :: Show a => a -> Text

-- | <tt><a>fmap</a></tt> for doubly-wrapped values
(<$$>) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
infixl 4 <$$>

module Restyler.Model.StatusesConfig

-- | Configuration for sending PR statuses
data StatusesConfig
StatusesConfig :: Bool -> Bool -> Bool -> StatusesConfig

-- | Send a failure status when there were differences
[scDifferences] :: StatusesConfig -> Bool

-- | Send a success status when there were no differences
[scNoDifferences] :: StatusesConfig -> Bool

-- | Send a failure status when there were errors
[scError] :: StatusesConfig -> Bool
defaultStatusesConfig :: StatusesConfig
instance GHC.Show.Show Restyler.Model.StatusesConfig.StatusesConfig
instance GHC.Classes.Eq Restyler.Model.StatusesConfig.StatusesConfig
instance Data.Aeson.Types.FromJSON.FromJSON Restyler.Model.StatusesConfig.StatusesConfig

module Restyler.Model.RemoteFile

-- | A remote (configuration) file, to fetch before restyling
data RemoteFile
RemoteFile :: URL -> FilePath -> RemoteFile

-- | Re-using GitHub's URL type
[rfUrl] :: RemoteFile -> URL
[rfPath] :: RemoteFile -> FilePath
instance GHC.Generics.Generic Restyler.Model.RemoteFile.RemoteFile
instance GHC.Show.Show Restyler.Model.RemoteFile.RemoteFile
instance GHC.Classes.Eq Restyler.Model.RemoteFile.RemoteFile
instance Data.Aeson.Types.FromJSON.FromJSON Restyler.Model.RemoteFile.RemoteFile

module Restyler.Capabilities.RemoteFile
class MonadRemoteFile m
fetchRemoteFile :: MonadRemoteFile m => RemoteFile -> m ()


-- | String specification of a Repository's Pull Request
--   
--   This shortened format is useful for passing a Pull Request as a
--   command-line argument, or showing it in log messages.
module Restyler.Model.PullRequestSpec
data PullRequestSpec
PullRequestSpec :: Name Owner -> Name Repo -> Int -> PullRequestSpec
[prsOwner] :: PullRequestSpec -> Name Owner
[prsRepo] :: PullRequestSpec -> Name Repo
[prsPullRequest] :: PullRequestSpec -> Int

-- | Parse <tt>&lt;owner&gt;/&lt;name&gt;#&lt;number&gt;</tt> into a
--   <tt><a>PullRequestSpec</a></tt>
parseSpec :: String -> Either String PullRequestSpec

-- | Inverse of <tt><a>parseSpec</a></tt>
showSpec :: PullRequestSpec -> Text
instance GHC.Show.Show Restyler.Model.PullRequestSpec.PullRequestSpec
instance GHC.Classes.Eq Restyler.Model.PullRequestSpec.PullRequestSpec

module Restyler.Options
data Options
Options :: Text -> LogLevel -> Bool -> Name Owner -> Name Repo -> Int -> Maybe URL -> Bool -> Options

-- | Personal or Installation access token
[oAccessToken] :: Options -> Text
[oLogLevel] :: Options -> LogLevel
[oLogColor] :: Options -> Bool
[oOwner] :: Options -> Name Owner
[oRepo] :: Options -> Name Repo
[oPullRequest] :: Options -> Int
[oJobUrl] :: Options -> Maybe URL
[oFake] :: Options -> Bool

-- | Parse required environment variables and command-line options
--   
--   See <tt>restyler --help</tt>
parseOptions :: IO Options

module Restyler.Model.PullRequest
pullRequestOwnerName :: PullRequest -> Name Owner
pullRequestRepoName :: HasCallStack => PullRequest -> Name Repo
pullRequestCloneUrl :: HasCallStack => PullRequest -> URL
pullRequestSpec :: HasCallStack => PullRequest -> PullRequestSpec

-- | Some API actions need to treat the PR like an Issue
pullRequestIssueId :: PullRequest -> Id Issue
pullRequestIsFork :: PullRequest -> Bool
pullRequestBaseRef :: PullRequest -> Text
pullRequestHeadRef :: PullRequest -> Text
pullRequestRemoteHeadRef :: PullRequest -> Text
pullRequestLocalHeadRef :: PullRequest -> Text
pullRequestRestyledBase :: PullRequest -> Text
pullRequestRestyledRef :: PullRequest -> Text

module Restyler.Model.Interpreter
data Interpreter
Sh :: Interpreter
Bash :: Interpreter
Python :: Interpreter
Ruby :: Interpreter

-- | Does that path start with a <i>shebang</i> for the given
--   <tt><a>Interpreter</a></tt>
hasInterpreter :: Text -> Interpreter -> Bool
instance GHC.Show.Show Restyler.Model.Interpreter.Interpreter
instance GHC.Classes.Eq Restyler.Model.Interpreter.Interpreter
instance Data.Aeson.Types.FromJSON.FromJSON Restyler.Model.Interpreter.Interpreter

module Restyler.Model.Include
data Include

-- | <pre>
--   **/*.hs
--   </pre>
Include :: Pattern -> Include

-- | <pre>
--   !**/*.temp
--   </pre>
Negated :: Pattern -> Include

-- | Determine if a set of <tt><a>Include</a></tt>s match a file
--   
--   Don't try to over-think this. It works how you would expect, and you
--   can confirm in its test cases.
includePath :: [Include] -> FilePath -> Bool
instance GHC.Show.Show Restyler.Model.Include.Include
instance GHC.Classes.Eq Restyler.Model.Include.Include
instance Data.Aeson.Types.FromJSON.FromJSON Restyler.Model.Include.Include
instance Data.String.IsString Restyler.Model.Include.Include

module Restyler.Content

-- | Simple for now: <tt>Restyled</tt>
commitMessage :: Text

-- | The comment to leave about a restyled Pull Request
commentBody :: PullRequest -> Text

-- | The more complicated comment to leave when we restyled PRs from forks
commentBodyFork :: PullRequest -> Text

module Restyler.Capabilities.System
class MonadSystem m
doesFileExist :: MonadSystem m => FilePath -> m Bool
getCurrentDirectory :: MonadSystem m => m FilePath
setCurrentDirectory :: MonadSystem m => FilePath -> m ()
readFile :: MonadSystem m => FilePath -> m Text
exitSuccess :: MonadSystem m => m a

module Restyler.Capabilities.GitHub
class MonadGitHub m
getPullRequest :: MonadGitHub m => Name Owner -> Name Repo -> Id PullRequest -> m PullRequest
findPullRequest :: MonadGitHub m => Name Owner -> Name Repo -> Text -> Text -> m (Maybe SimplePullRequest)
createPullRequest :: MonadGitHub m => Name Owner -> Name Repo -> CreatePullRequest -> m PullRequest
updatePullRequest :: MonadGitHub m => Name Owner -> Name Repo -> Id PullRequest -> EditPullRequest -> m PullRequest
getComments :: MonadGitHub m => Name Owner -> Name Repo -> Id Issue -> m (Vector IssueComment)
createComment :: MonadGitHub m => Name Owner -> Name Repo -> Id Issue -> Text -> m ()
deleteComment :: MonadGitHub m => Name Owner -> Name Repo -> Id Comment -> m ()
createStatus :: MonadGitHub m => Name Owner -> Name Repo -> Name Commit -> NewStatus -> m ()

module Restyler.Capabilities.Git
class MonadGit m

-- | <pre>
--   git clone &lt;url&gt; &lt;directory&gt;
--   </pre>
cloneRepository :: MonadGit m => Text -> FilePath -> m ()

-- | <pre>
--   git checkout [-b] &lt;branch&gt;
--   </pre>
checkoutBranch :: MonadGit m => Bool -> Text -> m ()

-- | <pre>
--   git diff --name-only &lt;branch&gt;
--   </pre>
changedPaths :: MonadGit m => Text -> m [FilePath]

-- | <pre>
--   git commit --all --message &lt;message&gt;
--   </pre>
commitAll :: MonadGit m => Text -> m ()

-- | <pre>
--   git fetch origin &lt;remote&gt;:&lt;local&gt;
--   </pre>
fetchOrigin :: MonadGit m => Text -> Text -> m ()

-- | <pre>
--   git push origin &lt;branch&gt;
--   </pre>
pushOrigin :: MonadGit m => Text -> m ()

-- | <pre>
--   git push --force-with-lease origin &lt;branch&gt;
--   </pre>
forcePushOrigin :: MonadGit m => Text -> m ()

module Restyler.Capabilities.Docker
class MonadDocker m
dockerRun :: MonadDocker m => [String] -> m ()

module Restyler.Model.Restyler

-- | How to run a given restyler
data Restyler
Restyler :: String -> String -> String -> [String] -> [Include] -> [Interpreter] -> Bool -> Bool -> Restyler

-- | Unique name for this restyler, not configurable
[rName] :: Restyler -> String

-- | Docker image for this restyler, not configurable
[rImage] :: Restyler -> String

-- | Command to run, usually the name, not configurable
[rCommand] :: Restyler -> String

-- | Arguments to pass before the paths
[rArguments] :: Restyler -> [String]

-- | Patterns to match for files to restyle
[rInclude] :: Restyler -> [Include]

-- | Interpreters to check for
[rInterpreters] :: Restyler -> [Interpreter]

-- | Can we pass <tt>--</tt> between arguments and paths
[rSupportsArgSep] :: Restyler -> Bool

-- | Can we pass multiple paths at once
[rSupportsMultiplePaths] :: Restyler -> Bool
defaultRestylers :: [Restyler]
allRestylers :: [Restyler]
namedRestyler :: MonadPlus m => Text -> m Restyler
unsafeNamedRestyler :: Text -> Restyler
runRestylers :: (Monad m, MonadSystem m, MonadDocker m, MonadLogger m) => [Restyler] -> [FilePath] -> m ()
instance GHC.Show.Show Restyler.Model.Restyler.Restyler
instance GHC.Classes.Eq Restyler.Model.Restyler.Restyler
instance Data.Aeson.Types.FromJSON.FromJSON Restyler.Model.Restyler.Restyler

module Restyler.Model.Config

-- | Top-level configuration object
data Config
Config :: Bool -> Bool -> [RemoteFile] -> StatusesConfig -> [Restyler] -> Config

-- | Do anything at all?
[cEnabled] :: Config -> Bool

-- | Just push the restyling, don't comment?
[cAuto] :: Config -> Bool

-- | Any remote configuration files to fetch before restyling
[cRemoteFiles] :: Config -> [RemoteFile]

-- | Send PR statuses?
[cStatusesConfig] :: Config -> StatusesConfig

-- | What restylers to run
[cRestylers] :: Config -> [Restyler]

-- | Default configuration
--   
--   <ul>
--   <li>Enabled</li>
--   <li>Not Auto</li>
--   <li>Send statuses</li>
--   <li>Run most restylers</li>
--   </ul>
defaultConfig :: Config

-- | <pre>
--   .restyled.yaml
--   </pre>
configPath :: FilePath
instance GHC.Show.Show Restyler.Model.Config.Config
instance GHC.Classes.Eq Restyler.Model.Config.Config
instance Data.Aeson.Types.FromJSON.FromJSON Restyler.Model.Config.Config

module Restyler.App

-- | Application environment
data App
App :: LogLevel -> Bool -> Text -> PullRequest -> Config -> Maybe SimplePullRequest -> App
[appLogLevel] :: App -> LogLevel
[appLogColor] :: App -> Bool
[appAccessToken] :: App -> Text

-- | The <tt><a>PullRequest</a></tt> we are restyling
[appPullRequest] :: App -> PullRequest

-- | Configuration loaded from <tt>.restyled.yaml</tt>
[appConfig] :: App -> Config

-- | Existing restyled <tt><a>PullRequest</a></tt> if it exists
[appRestyledPullRequest] :: App -> Maybe SimplePullRequest
data AppT m a
runAppT :: AppT m a -> ReaderT App (LoggingT (ExceptT AppError m)) a

-- | All possible application error conditions
data AppError

-- | We couldn't fetch the <tt><a>PullRequest</a></tt> to restyle
PullRequestFetchError :: Error -> AppError

-- | We couldn't clone or checkout the PR's branch
PullRequestCloneError :: IOException -> AppError

-- | We couldn't load a <tt>.restyled.yaml</tt>
ConfigurationError :: String -> AppError

-- | Error running a <tt>docker</tt> operation
DockerError :: IOException -> AppError

-- | Error running a <tt>git</tt> operation
GitError :: IOException -> AppError

-- | We encountered a GitHub API error during restyling
GitHubError :: Error -> AppError

-- | Trouble reading a file or etc
SystemError :: IOException -> AppError

-- | Trouble performing some HTTP request
RemoteFileError :: IOException -> AppError

-- | A minor escape hatch for <tt><a>IOException</a></tt>s
OtherError :: IOException -> AppError

-- | Run a computation, and modify any thrown <tt><a>AppError</a></tt>s
mapAppError :: MonadError AppError m => (AppError -> AppError) -> m a -> m a
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.Logger.MonadLogger (Restyler.App.AppT m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader Restyler.App.App (Restyler.App.AppT m)
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError Restyler.App.AppError (Restyler.App.AppT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Restyler.App.AppT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Restyler.App.AppT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Restyler.App.AppT m)
instance GHC.Show.Show Restyler.App.AppError
instance Control.Monad.IO.Class.MonadIO m => Restyler.Capabilities.Git.MonadGit (Restyler.App.AppT m)
instance Control.Monad.IO.Class.MonadIO m => Restyler.Capabilities.GitHub.MonadGitHub (Restyler.App.AppT m)
instance Control.Monad.IO.Class.MonadIO m => Restyler.Capabilities.System.MonadSystem (Restyler.App.AppT m)
instance Control.Monad.IO.Class.MonadIO m => Restyler.Capabilities.Docker.MonadDocker (Restyler.App.AppT m)
instance Control.Monad.IO.Class.MonadIO m => Restyler.Capabilities.RemoteFile.MonadRemoteFile (Restyler.App.AppT m)

module Restyler.Model.PullRequest.Status
data PullRequestStatus

-- | We found no differences after restyling
NoDifferencesStatus :: PullRequestStatus

-- | We found differences and opened a restyled <tt><a>PullRequest</a></tt>
DifferencesStatus :: URL -> PullRequestStatus

-- | We encountered an error and can link to a Job
ErrorStatus :: URL -> PullRequestStatus

-- | Send a <tt><a>PullRequestStatus</a></tt> for the original Pull Request
sendPullRequestStatus :: (MonadGitHub m, MonadReader App m) => PullRequestStatus -> m ()

-- | <tt><a>sendPullRequestStatus</a></tt> but ignore any exceptions
--   
--   This is useful for emitting the Errored status, where we wouldn't want
--   an exception here to muddy the debugging of the error we're reporting.
sendPullRequestStatus_ :: (MonadGitHub m, MonadError AppError m, MonadLogger m, MonadReader App m) => PullRequestStatus -> m ()

module Restyler.Model.PullRequest.Restyled

-- | Commit and push to the (new) restyled branch, and open a PR for it
createRestyledPullRequest :: (MonadGit m, MonadGitHub m, MonadLogger m, MonadReader App m) => m PullRequest

-- | Commit and force-push to the (existing) restyled branch
updateRestyledPullRequest :: (MonadGit m, MonadReader App m) => m ()

-- | Close the Restyled PR, if we know of it
--   
--   TODO: delete the branch
closeRestyledPullRequest :: (MonadGitHub m, MonadLogger m, MonadReader App m) => m ()

-- | Commit and push to current branch
updateOriginalPullRequest :: (MonadGit m, MonadReader App m) => m ()

module Restyler.Model.Comment

-- | Leave a comment on the original PR, mentioning the given Restyled PR
leaveRestyledComment :: (MonadGitHub m, MonadReader App m) => PullRequest -> m ()

-- | Locate any comments left by us on the origin PR and delete them
clearRestyledComments :: (MonadGitHub m, MonadLogger m, MonadReader App m) => m ()

module Restyler.Logger
runAppLoggingT :: MonadIO m => App -> LoggingT m a -> m a

module Restyler.App.Run

-- | Run an <tt><a>AppT</a></tt> action for real
--   
--   N.B. This unwraps only as far as <tt><a>ExceptT</a></tt> so that it
--   can be composed together with <tt><a>bootstrapApp</a></tt> and receive
--   overall error-handling after.
--   
--   See <tt><a>Restyler.Main</a></tt>.
runApp :: MonadIO m => App -> AppT m a -> ExceptT AppError m a

-- | Bootstrap the initial <tt><a>App</a></tt> type
--   
--   We want to have the <tt><a>PullRequest</a></tt> and
--   <tt><a>Config</a></tt> in our application environment, so we need them
--   to construct an <tt><a>App</a></tt>. However, it's valuable to use our
--   normal <tt><a>AppT</a></tt> instances to interact with GitHub or call
--   processes so we get the same logging and error-handling there.
--   
--   So this function uses a partial <tt><a>App</a></tt> value and
--   <tt><a>runApp</a></tt> to build the rest of it.
--   
--   If the actions given to <tt><a>runApp</a></tt> here try to access
--   <tt><a>appPullRequest</a></tt> or <tt><a>appConfig</a></tt>, they will
--   fail. So it's important those actions aren't refactored away from this
--   module, where that assumption is less obvious.
bootstrapApp :: Options -> FilePath -> ExceptT AppError IO App

module Restyler.Main

-- | The main entrypoint for the restyler CLI
--   
--   Parses command-line options, creates a temporary working directory and
--   runs the restyling process. Application errors are reported to
--   <tt>stderr</tt> before a non-zero exit.
--   
--   See <tt><a>parseOptions</a></tt> for usage information.
restylerMain :: IO ()
