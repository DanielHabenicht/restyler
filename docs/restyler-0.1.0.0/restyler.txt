-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package restyler
@version 0.1.0.0

module Restyler.Prelude

-- | <tt><a>when</a></tt> with a monadic condition
--   
--   <pre>
--   x &lt;- someMonadicConditional
--   when x $ do
--       someMonadicAction
--   
--   whenM someMonadicConditional someMonadicAction
--   </pre>
whenM :: Monad m => m Bool -> m () -> m ()

-- | Same for <tt><a>unless</a></tt>
unlessM :: Monad m => m Bool -> m () -> m ()

-- | <tt><a>Show</a></tt> as <tt><a>Text</a></tt>
tshow :: Show a => a -> Text

-- | <tt><a>fmap</a></tt> for doubly-wrapped values
(<$$>) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
infixl 4 <$$>
minimumBy :: (a -> a -> Ordering) -> [a] -> Maybe a
maximumBy :: (a -> a -> Ordering) -> [a] -> Maybe a


-- | String specification of a Repository's Pull Request
--   
--   This shortened format is useful for passing a Pull Request as a
--   command-line argument, or showing it in log messages.
module Restyler.Model.PullRequestSpec
data PullRequestSpec
PullRequestSpec :: Name Owner -> Name Repo -> Int -> PullRequestSpec
[prsOwner] :: PullRequestSpec -> Name Owner
[prsRepo] :: PullRequestSpec -> Name Repo
[prsPullRequest] :: PullRequestSpec -> Int

-- | Parse <tt>&lt;owner&gt;/&lt;name&gt;#&lt;number&gt;</tt> into a
--   <tt><a>PullRequestSpec</a></tt>
parseSpec :: String -> Either String PullRequestSpec

-- | Inverse of <tt><a>parseSpec</a></tt>
showSpec :: PullRequestSpec -> Text
instance GHC.Show.Show Restyler.Model.PullRequestSpec.PullRequestSpec
instance GHC.Classes.Eq Restyler.Model.PullRequestSpec.PullRequestSpec

module Restyler.Options
data Options
Options :: Text -> LogLevel -> Bool -> Name Owner -> Name Repo -> Int -> Maybe URL -> Bool -> Options

-- | Personal or Installation access token
[oAccessToken] :: Options -> Text
[oLogLevel] :: Options -> LogLevel
[oLogColor] :: Options -> Bool
[oOwner] :: Options -> Name Owner
[oRepo] :: Options -> Name Repo
[oPullRequest] :: Options -> Int
[oJobUrl] :: Options -> Maybe URL
[oFake] :: Options -> Bool

-- | Parse required environment variables and command-line options
--   
--   See <tt>restyler --help</tt>
parseOptions :: IO Options

module Restyler.Model.PullRequest
pullRequestOwnerName :: HasCallStack => PullRequest -> Name Owner
pullRequestRepoName :: HasCallStack => PullRequest -> Name Repo

-- | Clone URL appropriate to output in a message
--   
--   This is a URL that will work if you are otherwised authorized to clone
--   the repository (e.g.) you have an SSH key.
pullRequestCloneUrl :: HasCallStack => PullRequest -> URL

-- | Clone URL using the given Access Token
pullRequestCloneUrlToken :: HasCallStack => Text -> PullRequest -> Text
pullRequestSpec :: HasCallStack => PullRequest -> PullRequestSpec
simplePullRequestSpec :: SimplePullRequest -> PullRequestSpec

-- | Some API actions need to treat the PR like an Issue
pullRequestIssueId :: PullRequest -> Id Issue
pullRequestIsFork :: PullRequest -> Bool
pullRequestIsNonDefaultBranch :: HasCallStack => PullRequest -> Bool
pullRequestBaseRef :: PullRequest -> Text
pullRequestHeadRef :: PullRequest -> Text
pullRequestHeadSha :: PullRequest -> Text
pullRequestRemoteHeadRef :: PullRequest -> Text
pullRequestLocalHeadRef :: PullRequest -> Text
pullRequestRestyledBase :: PullRequest -> Text
pullRequestRestyledRef :: PullRequest -> Text
pullRequestRestyledMod :: PullRequest -> PullRequestMod

module Restyler.Model.Interpreter
data Interpreter
Sh :: Interpreter
Bash :: Interpreter
Python :: Interpreter
Ruby :: Interpreter

-- | Does that path start with a <i>shebang</i> for the given
--   <tt><a>Interpreter</a></tt>
hasInterpreter :: Text -> Interpreter -> Bool
instance GHC.Show.Show Restyler.Model.Interpreter.Interpreter
instance GHC.Classes.Eq Restyler.Model.Interpreter.Interpreter
instance Data.Aeson.Types.FromJSON.FromJSON Restyler.Model.Interpreter.Interpreter
instance Data.Aeson.Types.ToJSON.ToJSON Restyler.Model.Interpreter.Interpreter

module Restyler.Model.Include
data Include

-- | <pre>
--   **/*.hs
--   </pre>
Include :: Pattern -> Include

-- | <pre>
--   !**/*.temp
--   </pre>
Negated :: Pattern -> Include

-- | Determine if a set of <tt><a>Include</a></tt>s match a file
--   
--   Don't try to over-think this. It works how you would expect, and you
--   can confirm in its test cases.
includePath :: [Include] -> FilePath -> Bool
instance GHC.Show.Show Restyler.Model.Include.Include
instance GHC.Classes.Eq Restyler.Model.Include.Include
instance Data.Aeson.Types.FromJSON.FromJSON Restyler.Model.Include.Include
instance Data.Aeson.Types.ToJSON.ToJSON Restyler.Model.Include.Include
instance Data.String.IsString Restyler.Model.Include.Include

module Restyler.Model.Config.ExpectedKeys

-- | Validate there are no unexpected keys in an Object
--   
--   This is provided for convenience in the most common use-case. For a
--   more flexible interface, see <tt><a>validateExpectedKeyBy</a></tt>.
validateObjectKeys :: [String] -> HashMap Text v -> Parser ()

-- | Validate that a key is present in a list of (projected) items
--   
--   Returns the item found when validation passes.
--   
--   N.B. the <tt>[c]</tt> values are almost always going to be
--   <tt><a>String</a></tt>. It's typed as a list of <tt>c</tt> because the
--   only actual requirement is that there are equatable elements so we can
--   compute edit-distances.
--   
--   <pre>
--   &gt;&gt;&gt; validateExpectedKeyBy "key" fst [("foo", 1), ("bar", 2)] ("foo" :: String)
--   Right ("foo",1)
--   </pre>
validateExpectedKeyBy :: (Eq c, Show c) => String -> (a -> [c]) -> [a] -> [c] -> Either String a

module Restyler.Model.StatusesConfig

-- | Configuration for sending PR statuses
data StatusesConfig
StatusesConfig :: Bool -> Bool -> Bool -> StatusesConfig

-- | Send a failure status when there were differences
[scDifferences] :: StatusesConfig -> Bool

-- | Send a success status when there were no differences
[scNoDifferences] :: StatusesConfig -> Bool

-- | Send a failure status when there were errors
[scError] :: StatusesConfig -> Bool
defaultStatusesConfig :: StatusesConfig
instance GHC.Generics.Generic Restyler.Model.StatusesConfig.StatusesConfig
instance GHC.Show.Show Restyler.Model.StatusesConfig.StatusesConfig
instance GHC.Classes.Eq Restyler.Model.StatusesConfig.StatusesConfig
instance Data.Aeson.Types.FromJSON.FromJSON Restyler.Model.StatusesConfig.StatusesConfig
instance Data.Aeson.Types.ToJSON.ToJSON Restyler.Model.StatusesConfig.StatusesConfig

module Restyler.Model.Restyler

-- | How to run a given restyler
data Restyler
Restyler :: String -> String -> [String] -> [String] -> [Include] -> [Interpreter] -> Bool -> Bool -> Restyler

-- | Unique name for this restyler, not configurable
[rName] :: Restyler -> String

-- | Docker image for this restyler, not configurable
[rImage] :: Restyler -> String

-- | Command to run, usually the name, not configurable
--   
--   If there are arguments that are <b>always</b> required, such as a
--   sub-command or an inplace flag, they should be present here. This is
--   to avoid users accidentally overriding them out and being confused.
[rCommand] :: Restyler -> [String]

-- | Arguments to pass before the paths
[rArguments] :: Restyler -> [String]

-- | Patterns to match for files to restyle
[rInclude] :: Restyler -> [Include]

-- | Interpreters to check for
[rInterpreters] :: Restyler -> [Interpreter]

-- | Can we pass <tt>--</tt> between arguments and paths
[rSupportsArgSep] :: Restyler -> Bool

-- | Can we pass multiple paths at once
[rSupportsMultiplePaths] :: Restyler -> Bool
defaultRestylers :: [Restyler]
allRestylers :: [Restyler]
namedRestyler :: MonadPlus m => Text -> m Restyler
unsafeNamedRestyler :: Text -> Restyler
instance GHC.Show.Show Restyler.Model.Restyler.Restyler
instance GHC.Classes.Eq Restyler.Model.Restyler.Restyler
instance Data.Aeson.Types.FromJSON.FromJSON Restyler.Model.Restyler.RestylerOverrides
instance Data.Aeson.Types.FromJSON.FromJSON Restyler.Model.Restyler.Restyler
instance Data.Aeson.Types.ToJSON.ToJSON Restyler.Model.Restyler.Restyler

module Restyler.Model.RemoteFile

-- | A remote (configuration) file, to fetch before restyling
data RemoteFile
RemoteFile :: URL -> FilePath -> RemoteFile

-- | Re-using GitHub's URL type
[rfUrl] :: RemoteFile -> URL
[rfPath] :: RemoteFile -> FilePath
instance GHC.Generics.Generic Restyler.Model.RemoteFile.RemoteFile
instance GHC.Show.Show Restyler.Model.RemoteFile.RemoteFile
instance GHC.Classes.Eq Restyler.Model.RemoteFile.RemoteFile
instance Data.Aeson.Types.FromJSON.FromJSON Restyler.Model.RemoteFile.RemoteFile
instance Data.Aeson.Types.ToJSON.ToJSON Restyler.Model.RemoteFile.RemoteFile

module Restyler.Model.Config

-- | Top-level configuration object
data Config
Config :: Bool -> Bool -> [RemoteFile] -> Bool -> StatusesConfig -> [Restyler] -> Config

-- | Do anything at all?
[cEnabled] :: Config -> Bool

-- | Just push the restyling, don't comment?
[cAuto] :: Config -> Bool

-- | Any remote configuration files to fetch before restyling
[cRemoteFiles] :: Config -> [RemoteFile]

-- | Leave Comments?
[cCommentsEnabled] :: Config -> Bool

-- | Send PR statuses?
[cStatusesConfig] :: Config -> StatusesConfig

-- | What restylers to run
[cRestylers] :: Config -> [Restyler]

-- | Default configuration
--   
--   <ul>
--   <li>Enabled</li>
--   <li>Not Auto</li>
--   <li>Leave comments</li>
--   <li>Send statuses</li>
--   <li>Run most restylers</li>
--   </ul>
defaultConfig :: Config

-- | <pre>
--   .restyled.yaml
--   </pre>
configPath :: FilePath
instance GHC.Generics.Generic Restyler.Model.Config.Config
instance GHC.Show.Show Restyler.Model.Config.Config
instance GHC.Classes.Eq Restyler.Model.Config.Config
instance Data.Aeson.Types.FromJSON.FromJSON Restyler.Model.Config.Config
instance Data.Aeson.Types.ToJSON.ToJSON Restyler.Model.Config.Config

module Restyler.Content

-- | Simple for now: <tt>Restyled</tt>
commitMessage :: Text

-- | The comment to leave about a restyled Pull Request
commentBody :: PullRequest -> Text

-- | The more complicated comment to leave when we restyled PRs from forks
commentBodyFork :: HasCallStack => PullRequest -> Text

module Restyler.App.Type

-- | Application environment
data App
App :: LogLevel -> Bool -> Text -> PullRequest -> Maybe SimplePullRequest -> Config -> Options -> FilePath -> App
[appLogLevel] :: App -> LogLevel
[appLogColor] :: App -> Bool
[appAccessToken] :: App -> Text

-- | The <tt><a>PullRequest</a></tt> we are restyling
[appPullRequest] :: App -> PullRequest

-- | Existing restyled <tt><a>PullRequest</a></tt> if it exists
[appRestyledPullRequest] :: App -> Maybe SimplePullRequest

-- | Configuration loaded from <tt>.restyled.yaml</tt>
[appConfig] :: App -> Config

-- | Original command-line options
[appOptions] :: App -> Options

-- | Temporary directory we are working in
[appWorkingDirectory] :: App -> FilePath

-- | All possible application error conditions
data AppError

-- | We couldn't fetch the <tt><a>PullRequest</a></tt> to restyle
PullRequestFetchError :: Error -> AppError

-- | We couldn't clone or checkout the PR's branch
PullRequestCloneError :: IOException -> AppError

-- | We couldn't load a <tt>.restyled.yaml</tt>
ConfigurationError :: String -> AppError

-- | Error running a <tt>docker</tt> operation
DockerError :: IOException -> AppError

-- | We encountered a GitHub API error during restyling
GitHubError :: Error -> AppError

-- | Trouble reading a file or etc
SystemError :: IOException -> AppError

-- | Trouble performing some HTTP request
HttpError :: IOException -> AppError

-- | A minor escape hatch for <tt><a>IOException</a></tt>s
OtherError :: IOException -> AppError

-- | Run a computation, and modify any thrown <tt><a>AppError</a></tt>s
mapAppError :: MonadError AppError m => (AppError -> AppError) -> m a -> m a
newtype AppT m a
AppT :: ReaderT App (LoggingT (ExceptT AppError m)) a -> AppT m a
[runAppT] :: AppT m a -> ReaderT App (LoggingT (ExceptT AppError m)) a
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.Logger.MonadLogger (Restyler.App.Type.AppT m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader Restyler.App.Type.App (Restyler.App.Type.AppT m)
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError Restyler.App.Type.AppError (Restyler.App.Type.AppT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Restyler.App.Type.AppT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Restyler.App.Type.AppT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Restyler.App.Type.AppT m)
instance GHC.Show.Show Restyler.App.Type.AppError

module Restyler.App.Class
class (Monad m, MonadLogger m, MonadReader App m, MonadError AppError m) => MonadApp m
runGitHub :: MonadApp m => Request k a -> m a

-- | Fetch the first page using <tt><a>runGitHub</a></tt>, return the first
--   item
runGitHubFirst :: MonadApp m => (FetchCount -> Request k (Vector a)) -> m (Maybe a)

-- | <pre>
--   <a>void</a> . <a>runGitHub</a>
--   </pre>
runGitHub_ :: MonadApp m => Request k a -> m ()
getCurrentDirectory :: MonadApp m => m FilePath
setCurrentDirectory :: MonadApp m => FilePath -> m ()
doesFileExist :: MonadApp m => FilePath -> m Bool
readFile :: MonadApp m => FilePath -> m Text
exitSuccess :: MonadApp m => m ()
callProcess :: MonadApp m => String -> [String] -> m ()
readProcess :: MonadApp m => String -> [String] -> String -> m String
downloadFile :: MonadApp m => Text -> FilePath -> m ()
instance Control.Monad.IO.Class.MonadIO m => Restyler.App.Class.MonadApp (Restyler.App.Type.AppT m)

module Restyler.App

module Restyler.Model.Restyler.Run

-- | Runs the given <tt><a>Restyler</a></tt>s over the files
--   
--   Returns the subset of <tt>'Restyler</tt>'s that were actually invoked.
runRestylers :: MonadApp m => [Restyler] -> [FilePath] -> m [Restyler]

module Restyler.Model.PullRequest.Status
data PullRequestStatus

-- | We found no differences after restyling
NoDifferencesStatus :: PullRequestStatus

-- | We found differences and opened a restyled <tt><a>PullRequest</a></tt>
DifferencesStatus :: URL -> PullRequestStatus

-- | We encountered an error and can link to a Job
ErrorStatus :: URL -> PullRequestStatus

-- | Send a <tt><a>PullRequestStatus</a></tt> for the original Pull Request
sendPullRequestStatus :: MonadApp m => PullRequestStatus -> m ()

-- | <tt><a>sendPullRequestStatus</a></tt> but ignore any exceptions
--   
--   This is useful for emitting the Errored status, where we wouldn't want
--   an exception here to muddy the debugging of the error we're reporting.
sendPullRequestStatus_ :: MonadApp m => PullRequestStatus -> m ()

module Restyler.Model.PullRequest.Restyled

-- | Commit and push to the (new) restyled branch, and open a PR for it
createRestyledPullRequest :: (HasCallStack, MonadApp m) => [Restyler] -> m PullRequest

-- | Commit and force-push to the (existing) restyled branch
updateRestyledPullRequest :: MonadApp m => m ()

-- | Close the Restyled PR, if we know of it
--   
--   TODO: delete the branch
closeRestyledPullRequest :: MonadApp m => m ()

-- | Commit and push to current branch
updateOriginalPullRequest :: MonadApp m => m ()

module Restyler.Model.Comment

-- | Leave a comment on the original PR, mentioning the given Restyled PR
leaveRestyledComment :: (HasCallStack, MonadApp m) => PullRequest -> m ()

-- | Locate any comments left by us on the origin PR and delete them
clearRestyledComments :: (HasCallStack, MonadApp m) => m ()

module Restyler.Main
restylerMain :: (HasCallStack, MonadApp m) => m ()

module Restyler.Logger
runAppLoggingT :: MonadIO m => App -> LoggingT m a -> m a

module Restyler.Setup
restylerSetup :: (HasCallStack, MonadApp m) => m (PullRequest, Maybe SimplePullRequest, Config)

module Restyler.CLI

-- | The main entrypoint for the restyler CLI
--   
--   Parses command-line options, creates a temporary working directory and
--   runs the restyling process. Application errors are reported to
--   <tt>stderr</tt> before a non-zero exit. The PullRequest is sent an
--   error status as long as it has been initialized by the point of the
--   failure.
--   
--   See <tt><a>parseOptions</a></tt> for usage information.
restylerCLI :: IO ()
