-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Orphan instances for binary
--   
--   `binary-orphans` defines orphan instances for types in some popular
--   packages.
@package binary-orphans
@version 0.1.8.0


-- | Provides orphan <a>Binary</a> instances for types in various packages:
--   
--   <ul>
--   <li>aeson</li>
--   <li>scientific (prior to scientific-0.3.4.0)</li>
--   <li>semigroups</li>
--   <li>tagged</li>
--   <li>text (through text-binary, or text &gt;= 1.2.1)</li>
--   <li>time</li>
--   <li>unordered-containers</li>
--   <li>vector (through vector-binary-instances)</li>
--   </ul>
--   
--   Also there is <tt><a>Binary</a> <tt>Fixed</tt></tt> instance.
module Data.Binary.Orphans

-- | The <a>Binary</a> class provides <a>put</a> and <a>get</a>, methods to
--   encode and decode a Haskell value to a lazy <a>ByteString</a>. It
--   mirrors the <a>Read</a> and <a>Show</a> classes for textual
--   representation of Haskell types, and is suitable for serialising
--   Haskell values to disk, over the network.
--   
--   For decoding and generating simple external binary formats (e.g. C
--   structures), Binary may be used, but in general is not suitable for
--   complex protocols. Instead use the <a>Put</a> and <a>Get</a>
--   primitives directly.
--   
--   Instances of Binary should satisfy the following property:
--   
--   <pre>
--   decode . encode == id
--   </pre>
--   
--   That is, the <a>get</a> and <a>put</a> methods should be the inverse
--   of each other. A range of instances are provided for basic Haskell
--   types.
class Binary t

-- | Encode a value in the Put monad.
put :: Binary t => t -> Put

-- | Decode a value in the Get monad
get :: Binary t => Get t

-- | Encode a list of values in the Put monad. The default implementation
--   may be overridden to be more efficient but must still have the same
--   encoding format.
putList :: Binary t => [t] -> Put
instance Data.Binary.Class.Binary Data.Aeson.Types.Internal.Value
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k, Data.Binary.Class.Binary k, Data.Binary.Class.Binary v) => Data.Binary.Class.Binary (Data.HashMap.Base.HashMap k v)
instance (Data.Hashable.Class.Hashable v, GHC.Classes.Eq v, Data.Binary.Class.Binary v) => Data.Binary.Class.Binary (Data.HashSet.HashSet v)
instance (Data.Hashable.Class.Hashable a, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Hashable.Class.Hashed a)
instance forall k b (s :: k). Data.Binary.Class.Binary b => Data.Binary.Class.Binary (Data.Tagged.Tagged s b)
instance Data.Binary.Class.Binary Data.Time.Calendar.Days.Day
instance Data.Binary.Class.Binary Data.Time.Clock.Internal.UniversalTime.UniversalTime
instance Data.Binary.Class.Binary Data.Time.Clock.Internal.DiffTime.DiffTime
instance Data.Binary.Class.Binary Data.Time.Clock.Internal.UTCTime.UTCTime
instance Data.Binary.Class.Binary Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime
instance Data.Binary.Class.Binary Data.Time.LocalTime.Internal.TimeZone.TimeZone
instance Data.Binary.Class.Binary Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance Data.Binary.Class.Binary Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Data.Binary.Class.Binary Data.Time.LocalTime.Internal.ZonedTime.ZonedTime
instance Data.Binary.Class.Binary Data.Time.Clock.Internal.AbsoluteTime.AbsoluteTime
instance Data.Binary.Class.Binary Data.Time.Clock.Internal.SystemTime.SystemTime
instance (Data.CaseInsensitive.Internal.FoldCase a, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.CaseInsensitive.Internal.CI a)
