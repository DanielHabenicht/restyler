-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parse environment variables
--   
--   Here's a simple example of a program that uses <tt>envparse</tt>'s
--   parser:
--   
--   <pre>
--   module Main (main) where
--   
--   import Control.Monad (unless)
--   import Env
--   
--   data Hello = Hello { name :: String, quiet :: Bool }
--   
--   hello :: IO Hello
--   hello = Env.parse (header "envparse example") $
--     Hello &lt;$&gt; var (str &lt;=&lt; nonempty) "NAME"  (help "Target for the greeting")
--           &lt;*&gt; switch                 "QUIET" (help "Whether to actually print the greeting")
--    
--   main :: IO ()
--   main = do
--     Hello {name, quiet} &lt;- hello
--     unless quiet $
--       putStrLn ("Hello, " ++ name ++ "!")
--   </pre>
--   
--   The <tt>NAME</tt> environment variable is mandatory and contains the
--   name of the person to greet. <tt>QUIET</tt>, on the other hand, is an
--   optional boolean flag, false by default, that decides whether the
--   greeting should be silent.
--   
--   If the <tt>NAME</tt> variable is undefined in the environment then
--   running the program will result in the following help text:
--   
--   <pre>
--   envparse example
--    
--   Available environment variables:
--    
--     NAME                   Target for the greeting
--     QUIET                  Whether to actually print the
--                            greeting
--    
--   Parsing errors:
--    
--     NAME is unset
--   </pre>
@package envparse
@version 0.4


-- | This module contains an extensible error infrastructure.
--   
--   Each kind of errors gets a separate type class which encodes a
--   <tt>Prism</tt> (roughly a getter and a constructor). The
--   <tt>Reader</tt>s, then, have the constraints for precisely the set of
--   errors they can return.
module Env.Internal.Error

-- | The type of errors returned by <tt>envparse</tt>'s <tt>Reader</tt>s.
--   These fall into 3 categories:
--   
--   <ul>
--   <li>Variables that are unset in the environment.</li>
--   <li>Variables whose value is empty.</li>
--   <li>Variables whose value cannot be parsed using the <a>Read</a>
--   instance.</li>
--   </ul>
data Error
UnsetError :: Error
EmptyError :: Error
UnreadError :: String -> Error

-- | The class of types that contain and can be constructed from the error
--   returned from parsing unset variables.
class AsUnset e
unset :: AsUnset e => e
tryUnset :: AsUnset e => e -> Maybe ()

-- | The class of types that contain and can be constructed from the error
--   returned from parsing variables whose value is empty.
class AsEmpty e
empty :: AsEmpty e => e
tryEmpty :: AsEmpty e => e -> Maybe ()

-- | The class of types that contain and can be constructed from the error
--   returned from parsing variable whose value cannot be parsed using the
--   <a>Read</a> instance.
class AsUnread e
unread :: AsUnread e => String -> e
tryUnread :: AsUnread e => e -> Maybe String
instance GHC.Classes.Eq Env.Internal.Error.Error
instance GHC.Show.Show Env.Internal.Error.Error
instance Env.Internal.Error.AsUnread Env.Internal.Error.Error
instance Env.Internal.Error.AsEmpty Env.Internal.Error.Error
instance Env.Internal.Error.AsUnset Env.Internal.Error.Error


-- | <tt>Alt F</tt> is the free <a>Alternative</a> functor on <tt>F</tt>
module Env.Internal.Free
data Alt f a
[Nope] :: Alt f a
[Pure] :: a -> Alt f a
[Ap] :: Alt f (a -> b) -> Alt f a -> Alt f b
[Alt] :: Alt f a -> Alt f a -> Alt f a
[Lift] :: f a -> Alt f a
liftAlt :: f a -> Alt f a
runAlt :: forall f g a. Alternative g => (forall x. f x -> g x) -> Alt f a -> g a
foldAlt :: Monoid p => (forall a. f a -> p) -> Alt f b -> p
hoistAlt :: forall f g b. Functor g => (forall a. f a -> g a) -> Alt f b -> Alt g b

-- | Print the free structure
inspect :: Alt f a -> String
instance GHC.Classes.Eq m => GHC.Classes.Eq (Env.Internal.Free.Mon m a)
instance GHC.Show.Show m => GHC.Show.Show (Env.Internal.Free.Mon m a)
instance GHC.Base.Functor (Env.Internal.Free.Mon m)
instance GHC.Base.Monoid m => GHC.Base.Applicative (Env.Internal.Free.Mon m)
instance GHC.Base.Monoid m => GHC.Base.Alternative (Env.Internal.Free.Mon m)
instance GHC.Base.Functor f => GHC.Base.Functor (Env.Internal.Free.Alt f)
instance GHC.Base.Functor f => GHC.Base.Applicative (Env.Internal.Free.Alt f)
instance GHC.Base.Functor f => GHC.Base.Alternative (Env.Internal.Free.Alt f)

module Env.Internal.Val

-- | A type isomorphic to <a>Either</a> with the accumulating
--   <a>Applicative</a> instance.
data Val e a
Err :: e -> Val e a
Ok :: a -> Val e a
fromEither :: Either e a -> Val e a
toEither :: Val e a -> Either e a
instance (GHC.Classes.Eq a, GHC.Classes.Eq e) => GHC.Classes.Eq (Env.Internal.Val.Val e a)
instance (GHC.Show.Show a, GHC.Show.Show e) => GHC.Show.Show (Env.Internal.Val.Val e a)
instance GHC.Base.Functor (Env.Internal.Val.Val e)
instance GHC.Base.Monoid e => GHC.Base.Applicative (Env.Internal.Val.Val e)
instance GHC.Base.Monoid e => GHC.Base.Alternative (Env.Internal.Val.Val e)

module Env.Internal.Parser

-- | An environment parser
newtype Parser e a
Parser :: Alt (VarF e) a -> Parser e a
[unParser] :: Parser e a -> Alt (VarF e) a
data VarF e a
VarF :: String -> (String -> Map String String -> Either e a) -> Maybe String -> Maybe a -> Maybe String -> Bool -> VarF e a
[varfName] :: VarF e a -> String
[varfReader] :: VarF e a -> String -> Map String String -> Either e a
[varfHelp] :: VarF e a -> Maybe String
[varfDef] :: VarF e a -> Maybe a
[varfHelpDef] :: VarF e a -> Maybe String
[varfKeep] :: VarF e a -> Bool

-- | Try to parse a pure environment
parsePure :: Parser e a -> [(String, String)] -> Either [(String, e)] a
eachUnsetVar :: Applicative m => Parser e a -> (String -> m b) -> m ()

-- | This represents a modification of the properties of a particular
--   <a>Parser</a>. Combine them using the <a>Monoid</a> instance.
newtype Mod t a
Mod :: (t a -> t a) -> Mod t a

-- | The string to prepend to the name of every declared environment
--   variable
prefixed :: String -> Parser e a -> Parser e a

-- | Parse a particular variable from the environment
--   
--   <pre>
--   &gt;&gt;&gt; var <a>str</a> "EDITOR" (<a>def</a> "vim" &lt;&gt; <a>helpDef</a> show)
--   </pre>
var :: AsUnset e => Reader e a -> String -> Mod Var a -> Parser e a

-- | Environment variable metadata
data Var a
Var :: Maybe String -> Maybe (a -> String) -> Maybe a -> Bool -> Var a
[varHelp] :: Var a -> Maybe String
[varHelpDef] :: Var a -> Maybe (a -> String)
[varDef] :: Var a -> Maybe a
[varKeep] :: Var a -> Bool
defaultVar :: Var a

-- | An environment variable's value parser. Use <tt>(&lt;=&lt;)</tt> and
--   <tt>(&gt;=&gt;)</tt> to combine these
type Reader e a = String -> Either e a

-- | The trivial reader
str :: IsString s => Reader e s

-- | The reader that accepts only non-empty strings
nonempty :: (AsEmpty e, IsString s) => Reader e s

-- | The reader that splits a string into a list of strings consuming the
--   separator.
splitOn :: Char -> Reader e [String]

-- | The reader that uses the <a>Read</a> instance of the type
auto :: (AsUnread e, Read a) => Reader e a

-- | The default value of the variable
--   
--   <i>Note:</i> specifying it means the parser won't ever fail.
def :: a -> Mod Var a

-- | Show the default value of the variable in help.
helpDef :: (a -> String) -> Mod Var a

-- | Use the <a>Show</a> instance to show the default value of the variable
--   in help.
showDef :: Show a => Mod Var a

-- | A flag that takes the active value if the environment variable is set
--   and non-empty and the default value otherwise
--   
--   <i>Note:</i> this parser never fails.
flag :: a -> a -> String -> Mod Flag a -> Parser e a

-- | A simple boolean <a>flag</a>
--   
--   <i>Note:</i> this parser never fails.
switch :: String -> Mod Flag Bool -> Parser e Bool

-- | Flag metadata
data Flag a

-- | A class of things that can have a help message attached to them
class HasHelp t

-- | Attach help text to the variable
help :: HasHelp t => String -> Mod t a

-- | A class of things that can be still kept in an environment when the
--   parsing has been completed.
class HasKeep t

-- | Keep a variable.
keep :: HasKeep t => Mod t a
instance GHC.Base.Functor (Env.Internal.Parser.Parser e)
instance GHC.Base.Functor (Env.Internal.Parser.VarF e)
instance Env.Internal.Parser.HasKeep Env.Internal.Parser.Var
instance Env.Internal.Parser.HasKeep Env.Internal.Parser.Flag
instance Env.Internal.Parser.HasHelp Env.Internal.Parser.Var
instance Env.Internal.Parser.HasHelp Env.Internal.Parser.Flag
instance GHC.Base.Monoid (Env.Internal.Parser.Mod t a)
instance GHC.Base.Applicative (Env.Internal.Parser.Parser e)
instance GHC.Base.Alternative (Env.Internal.Parser.Parser e)

module Env.Internal.Help
helpInfo :: Info e -> Parser e b -> [(String, e)] -> String

-- | A pretty-printed list of recognized environment variables suitable for
--   usage messages
helpDoc :: Parser e a -> String

-- | Parser's metadata
data Info e

-- | Given a variable name and an error value, try to produce a useful
--   error message
type ErrorHandler e = String -> e -> Maybe String
defaultInfo :: Info Error

-- | The default error handler
defaultErrorHandler :: (AsUnset e, AsEmpty e, AsUnread e) => ErrorHandler e

-- | Set the help text header (it usually includes the application's name
--   and version)
header :: String -> Info e -> Info e

-- | Set the short description
desc :: String -> Info e -> Info e

-- | Set the help text footer (it usually includes examples)
footer :: String -> Info e -> Info e

-- | An error handler
handleError :: ErrorHandler e -> Info x -> Info e


-- | Here's a simple example of a program that uses <tt>envparse</tt>'s
--   parser:
--   
--   <pre>
--   module Main (main) where
--   
--   import Control.Monad (unless)
--   import Env
--   
--   data Hello = Hello { name :: String, quiet :: Bool }
--   
--   hello :: IO Hello
--   hello = Env.<a>parse</a> (<a>header</a> "envparse example") $
--     Hello &lt;$&gt; <a>var</a> (<a>str</a> &lt;=&lt; <a>nonempty</a>) "NAME"  (<a>help</a> "Target for the greeting")
--           &lt;*&gt; <a>switch</a>                 "QUIET" (<a>help</a> "Whether to actually print the greeting")
--   
--   main :: IO ()
--   main = do
--     Hello {name, quiet} &lt;- hello
--     unless quiet $
--       putStrLn ("Hello, " ++ name ++ "!")
--   </pre>
--   
--   The <tt>NAME</tt> environment variable is mandatory and contains the
--   name of the person to greet. <tt>QUIET</tt>, on the other hand, is an
--   optional boolean flag, false by default, that decides whether the
--   greeting should be silent.
--   
--   If the <tt>NAME</tt> variable is undefined in the environment then
--   running the program will result in the following help text:
--   
--   <pre>
--   envparse example
--   
--   Available environment variables:
--   
--     NAME                   Target for the greeting
--     QUIET                  Whether to actually print the
--                            greeting
--   
--   Parsing errors:
--   
--     NAME is unset
--   </pre>
module Env

-- | Parse the environment or die
--   
--   Prints the help text and exits with <tt>EXIT_FAILURE</tt> on
--   encountering a parse error.
--   
--   <pre>
--   &gt;&gt;&gt; parse (<a>header</a> "env-parse 0.2.0") (<a>var</a> <a>str</a> "USER" (<a>def</a> "nobody"))
--   </pre>
parse :: (Info Error -> Info e) -> Parser e a -> IO a

-- | Try to parse the environment
--   
--   Use this if simply dying on failure (the behavior of <a>parse</a>) is
--   inadequate for your needs.
parseOr :: (String -> IO a) -> (Info Error -> Info e) -> Parser e b -> IO (Either a b)

-- | An environment parser
data Parser e a

-- | This represents a modification of the properties of a particular
--   <a>Parser</a>. Combine them using the <a>Monoid</a> instance.
data Mod t a

-- | Parser's metadata
data Info e

-- | Set the help text header (it usually includes the application's name
--   and version)
header :: String -> Info e -> Info e

-- | Set the short description
desc :: String -> Info e -> Info e

-- | Set the help text footer (it usually includes examples)
footer :: String -> Info e -> Info e

-- | An error handler
handleError :: ErrorHandler e -> Info x -> Info e

-- | Given a variable name and an error value, try to produce a useful
--   error message
type ErrorHandler e = String -> e -> Maybe String

-- | The default error handler
defaultErrorHandler :: (AsUnset e, AsEmpty e, AsUnread e) => ErrorHandler e

-- | The string to prepend to the name of every declared environment
--   variable
prefixed :: String -> Parser e a -> Parser e a

-- | Parse a particular variable from the environment
--   
--   <pre>
--   &gt;&gt;&gt; var <a>str</a> "EDITOR" (<a>def</a> "vim" &lt;&gt; <a>helpDef</a> show)
--   </pre>
var :: AsUnset e => Reader e a -> String -> Mod Var a -> Parser e a

-- | Environment variable metadata
data Var a

-- | An environment variable's value parser. Use <tt>(&lt;=&lt;)</tt> and
--   <tt>(&gt;=&gt;)</tt> to combine these
type Reader e a = String -> Either e a

-- | The trivial reader
str :: IsString s => Reader e s

-- | The reader that accepts only non-empty strings
nonempty :: (AsEmpty e, IsString s) => Reader e s

-- | The reader that splits a string into a list of strings consuming the
--   separator.
splitOn :: Char -> Reader e [String]

-- | The reader that uses the <a>Read</a> instance of the type
auto :: (AsUnread e, Read a) => Reader e a

-- | The default value of the variable
--   
--   <i>Note:</i> specifying it means the parser won't ever fail.
def :: a -> Mod Var a

-- | Show the default value of the variable in help.
helpDef :: (a -> String) -> Mod Var a

-- | A flag that takes the active value if the environment variable is set
--   and non-empty and the default value otherwise
--   
--   <i>Note:</i> this parser never fails.
flag :: a -> a -> String -> Mod Flag a -> Parser e a

-- | A simple boolean <a>flag</a>
--   
--   <i>Note:</i> this parser never fails.
switch :: String -> Mod Flag Bool -> Parser e Bool

-- | Flag metadata
data Flag a

-- | A class of things that can have a help message attached to them
class HasHelp t

-- | Attach help text to the variable
help :: HasHelp t => String -> Mod t a

-- | A class of things that can be still kept in an environment when the
--   parsing has been completed.
class HasKeep t

-- | Keep a variable.
keep :: HasKeep t => Mod t a

-- | A pretty-printed list of recognized environment variables suitable for
--   usage messages
helpDoc :: Parser e a -> String

-- | The type of errors returned by <tt>envparse</tt>'s <tt>Reader</tt>s.
--   These fall into 3 categories:
--   
--   <ul>
--   <li>Variables that are unset in the environment.</li>
--   <li>Variables whose value is empty.</li>
--   <li>Variables whose value cannot be parsed using the <a>Read</a>
--   instance.</li>
--   </ul>
data Error
UnsetError :: Error
EmptyError :: Error
UnreadError :: String -> Error

-- | The class of types that contain and can be constructed from the error
--   returned from parsing unset variables.
class AsUnset e
unset :: AsUnset e => e
tryUnset :: AsUnset e => e -> Maybe ()

-- | The class of types that contain and can be constructed from the error
--   returned from parsing variables whose value is empty.
class AsEmpty e
empty :: AsEmpty e => e
tryEmpty :: AsEmpty e => e -> Maybe ()

-- | The class of types that contain and can be constructed from the error
--   returned from parsing variable whose value cannot be parsed using the
--   <a>Read</a> instance.
class AsUnread e
unread :: AsUnread e => String -> e
tryUnread :: AsUnread e => e -> Maybe String

-- | One or none.
optional :: Alternative f => f a -> f Maybe a

-- | Right-to-left Kleisli composition of monads.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | An infix synonym for <a>mappend</a>.
(<>) :: Monoid m => m -> m -> m
infixr 6 <>

-- | The sum of a collection of actions, generalizing <a>concat</a>.
asum :: (Foldable t, Alternative f) => t f a -> f a

-- | Try to parse a pure environment
parsePure :: Parser e a -> [(String, String)] -> Either [(String, e)] a


-- | Using the <a>Generic</a> facility, this module can derive
--   <a>Parser</a>s automatically.
--   
--   If you have a simple record:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   {-# LANGUAGE MultiParamTypeClasses #-}
--   
--   import Env
--   import Env.Generic
--   
--   data Hello = Hello
--     { name  :: String
--     , count :: Int
--     , quiet :: Bool
--     } deriving (Show, Eq, Generic)
--   
--   instance Record Error Hello
--   
--   main :: IO ()
--   main = do
--     hello &lt;- Env.parse (header "envparse example") <a>record</a>
--     print (hello :: Hello)
--   </pre>
--   
--   The generic implementation of the <a>record</a> method translates
--   named fields to field parsers:
--   
--   <pre>
--   % NAME=bob COUNT=3 runhaskell -isrc example/Generic0.hs
--   Hello {name = "bob", count = 3, quiet = False}
--   </pre>
--   
--   If you want to adorn the ugly default help message, augment the fields
--   with descriptions:
--   
--   <pre>
--   {-# LANGUAGE DataKinds #-}
--   {-# LANGUAGE DeriveGeneric #-}
--   {-# LANGUAGE MultiParamTypeClasses #-}
--   {-# LANGUAGE TypeOperators #-}
--   
--   import Env
--   import Env.Generic
--   
--   data Hello = Hello
--     { name  :: String ? <b>"Whom shoud I greet?"</b>
--     , count :: Int    ? <b>"How many times to greet them?"</b>
--     , quiet :: Bool   ? <b>"Should I be quiet instead?"</b>
--     } deriving (Show, Eq, Generic)
--   
--   instance Record Error Hello
--   
--   main :: IO ()
--   main = do
--     hello &lt;- Env.parse (header "envparse example") record
--     print (hello :: Hello)
--   </pre>
--   
--   <pre>
--   % runhaskell -isrc example/Generic1.hs
--   envparse example
--   
--   Available environment variables:
--   
--     COUNT                  <b>How many times to greet them?</b>
--     NAME                   <b>Whom shoud I greet?</b>
--     QUIET                  <b>Should I be quiet instead?</b>
--   
--   Parsing errors:
--   
--     COUNT is unset
--     NAME is unset
--   </pre>
--   
--   Note that this has an effect of wrapping the values in the <a>Help</a>
--   constructor:
--   
--   <pre>
--   % NAME=bob COUNT=3 QUIET=<tt>YES</tt> runhaskell -isrc example/Generic1.hs
--   Hello {name = Help {unHelp = "bob"}, count = Help {unHelp = 3}, quiet = Help {unHelp = True}}
--   </pre>
module Env.Generic

-- | Given a <tt>Record e a</tt> instance, a value of the type <tt>a</tt>
--   can be parsed from the environment. If the parsing fails, a value of
--   an error type <tt>e</tt> is returned.
--   
--   The <a>record</a> method has a default implementation for any type
--   that has a <a>Generic</a> instance. If you need to choose a concrete
--   type for <tt>e</tt>, the default error type <a>Error</a> is a good
--   candidate. Otherwise, the features you'll use in your parsers will
--   naturally guide GHC to compute the set of required constraints on
--   <tt>e</tt>.
class Record e a
record :: Record e a => Parser e a
record :: (Record e a, r ~ Rep a, Generic a, GRecord e r) => Parser e a

-- | Given a <tt>Field e a</tt> instance, a value of the type <tt>a</tt>
--   can be parsed from an environment variable. If the parsing fails, a
--   value of an error type <tt>e</tt> is returned.
--   
--   The <a>field</a> method has a default implementation for any type that
--   has a <a>Read</a> instance. If you need to choose a concrete type for
--   <tt>e</tt>, the default error type <a>Error</a> is a good candidate.
--   Otherwise, the features you'll use in your parsers will naturally
--   guide GHC to compute the set of required constraints on <tt>e</tt>.
--   
--   The annotated instances do not use the default implementation.
class Field e a
field :: Field e a => String -> Maybe String -> Parser e a
field :: (Field e a, AsUnset e, AsUnread e, Read a) => String -> Maybe String -> Parser e a

-- | A field annotation.
--   
--   If you annotate a record field with a <tt>Symbol</tt> literal (that
--   is, a statically known type level string) the derivation machinery
--   will use the literal in the help message.
--   
--   Please remember that the values of the annotated fields are wrapped in
--   the <a>Help</a> constructor.
newtype a (?) tag
Help :: a -> (?) a tag
[unHelp] :: (?) a tag -> a

-- | Representable types of kind *. This class is derivable in GHC with the
--   DeriveGeneric flag on.
class Generic a
instance Data.Traversable.Traversable ((Env.Generic.?) a)
instance Data.Foldable.Foldable ((Env.Generic.?) a)
instance GHC.Base.Functor ((Env.Generic.?) a)
instance forall a k (tag :: k). GHC.Classes.Eq a => GHC.Classes.Eq (a Env.Generic.? tag)
instance forall a k (tag :: k). GHC.Show.Show a => GHC.Show.Show (a Env.Generic.? tag)
instance GHC.Classes.Eq Env.Generic.State
instance GHC.Show.Show Env.Generic.State
instance (GHC.TypeLits.KnownSymbol tag, Env.Generic.Field e a) => Env.Generic.Field e (a Env.Generic.? tag)
instance Env.Generic.Field e a => Env.Generic.GRecord e (GHC.Generics.K1 i a)
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Types.Int
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Int.Int8
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Int.Int16
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Int.Int32
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Int.Int64
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Integer.Type.Integer
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Types.Word
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Word.Word8
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Word.Word16
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Word.Word32
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Word.Word64
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Natural.Natural
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Types.Float
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Types.Double
instance Env.Internal.Error.AsUnset e => Env.Generic.Field e GHC.Base.String
instance (Env.Internal.Error.AsUnset e, Env.Internal.Error.AsUnread e) => Env.Generic.Field e GHC.Types.Char
instance Env.Generic.Field e GHC.Types.Bool
instance forall k e (a :: k -> *) (c :: GHC.Generics.Meta). Env.Generic.GRecord e a => Env.Generic.GRecord e (GHC.Generics.D1 c a)
instance forall k (c :: GHC.Generics.Meta) e (a :: k -> *). (GHC.Generics.Constructor c, Env.Generic.GRecord e a) => Env.Generic.GRecord e (GHC.Generics.C1 c a)
instance forall k e (f :: k -> *) (g :: k -> *). (Env.Generic.GRecord e f, Env.Generic.GRecord e g) => Env.Generic.GRecord e (f GHC.Generics.:*: g)
instance forall k e (f :: k -> *) (g :: k -> *). (Env.Generic.GRecord e f, Env.Generic.GRecord e g) => Env.Generic.GRecord e (f GHC.Generics.:+: g)
instance forall k (c :: GHC.Generics.Meta) (x1 :: GHC.Types.Symbol) (x2 :: GHC.Generics.SourceUnpackedness) (x3 :: GHC.Generics.SourceStrictness) (x4 :: GHC.Generics.DecidedStrictness) e (a :: k -> *). (GHC.Generics.Selector c, c ~ 'GHC.Generics.MetaSel ('GHC.Base.Just x1) x2 x3 x4, Env.Generic.GRecord e a) => Env.Generic.GRecord e (GHC.Generics.S1 c a)
